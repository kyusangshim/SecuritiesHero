server:
  port: 8081


# Application Configuration
app:
  kafka:
    enabled: ${APP_KAFKA_ENABLED:true}   # ë¸Œë¡œì»¤/ì¹´í”„ì¹´ ì•ˆì“¸ ë• false ë¡œ ì‹¤í–‰

logging:
  level:
    # Kafka ë¡œê·¸ ë ˆë²¨ ìŠ¤ìœ„ì¹˜ (ë¸Œë¡œì»¤/AI ì¹´í”„ì¹´ ì•ˆì“¸ ë•Œ OFF ë¡œ)
    org.apache.kafka: ${APP_KAFKA_LOG_LEVEL:INFO}
    org.springframework.kafka: ${APP_KAFKA_LOG_LEVEL:INFO}
    # MCP ë¡œê·¸ë ˆë²¨
    org.springframework.ai.mcp: DEBUG
    io.modelcontextprotocol: DEBUG

spring:
  config:
    import: optional:file:.env[.properties]
  jackson:
    property-naming-strategy: SNAKE_CASE
  ai:
    model:
      chat: openai
    openai:
      api-key: ${OPENAI_API_KEY}
      base-url: ${OPENAI_BASE_URL}
      chat:
        options:
          model: ${OPENAI_MODEL}
          temperature: 1
    # MCP Client: STDIOë¡œ DuckDuckGo MCPë¥¼ ìì‹ í”„ë¡œì„¸ìŠ¤ë¡œ ì‹¤í–‰
    mcp:
      client:
        enabled: true
        type: SYNC     # SYNC or ASYNC
        stdio:
          connections:
            duck: # ì—°ê²° ì´ë¦„
              command: ${DDG_CMD}
              args: [ ]
            tavily:
              command: ${NPX_PATH:npx}
              args:
                - -y
                - mcp-remote
                - https://mcp.tavily.com/mcp/?tavilyApiKey=${TAVILY_API_KEY}
  # Kafka Configuration
  kafka:
    bootstrap-servers: ${KAFKA_BOOTSTRAP_SERVERS}
    # ë¸Œë¡œì»¤ ì—†ì„ ë•Œ ë¦¬ìŠ¤ë„ˆ ìì²´ë¥¼ ì‹œì‘í•˜ì§€ ì•ŠìŒ
    listener:
      auto-startup: ${app.kafka.enabled:true}
      missing-topics-fatal: false
    # ë¸Œë¡œì»¤ ì—†ì–´ë„ ë¶€íŒ… ì‹¤íŒ¨í•˜ì§€ ì•Šê²Œ
    admin:
      fail-fast: false
    # ì¬ì ‘ì† ë¡œê·¸ ë¹ˆë„ ë‚®ì¶”ê¸° (ì„ íƒ)
    properties:
      reconnect.backoff.ms: 10000
      reconnect.backoff.max.ms: 60000
      retry.backoff.ms: 10000

    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.apache.kafka.common.serialization.StringSerializer
      acks: all
      retries: 3
      properties:
        max.request.size: ${KAFKA_MAX_REQUEST_SIZE:5242880}   # ğŸ”¹ í”„ë¡œë“€ì„œ ë©”ì‹œì§€ í¬ê¸°
    consumer:
      # AI ì„œë²„ìš© group-id
      group-id: ${KAFKA_CONSUMER_GROUP:ai-server-group}
      # FastAPI ì „ìš© group-id
      fastapi-group-id: ${KAFKA_FASTAPI_CONSUMER_GROUP:fastapi-backend-group}
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      auto-offset-reset: earliest
      enable-auto-commit: true
      properties:
        fetch.max.bytes: ${KAFKA_FETCH_MAX_BYTES:5242880}             # ğŸ”¹ ì»¨ìŠˆë¨¸ ì „ì²´ fetch
        max.partition.fetch.bytes: ${KAFKA_MAX_PARTITION_FETCH_BYTES:5242880}  # ğŸ”¹

  # Opensearch - ë³´ì•ˆX(HTTP, ê¸°ë³¸ ì¸ì¦ ì—†ìŒ)
  opensearch:
    uris: ${OPENSEARCH_URIS} # ë³µìˆ˜í˜•ìœ¼ë¡œ ë³€ê²½í•˜ì—¬ ì„¤ì • ì†ì„±ê³¼ ì¼ì¹˜ì‹œí‚´
    connection-timeout: 5s     # connect timeout
    socket-timeout: 60s        # read timeout
    max-conn-total: 100
    max-conn-per-route: 100
    sniff-enabled: false       # Managed/ë¡œì»¬ ëª¨ë‘ ê¸°ë³¸ false ê¶Œì¥
